/**
 * Builder Executor
 *
 * Builds TypeScript packages with dual CJS/ESM output and transforms package.json for publishing.
 * - Compiles TypeScript to both CommonJS (dist/) and ES Modules (dist/esm/)
 * - Automatically strips "dist/" prefixes from package.json entry points for npm publishing
 */

import { ExecutorContext } from '@nx/devkit';
import { tscExecutor } from '@nx/js/src/executors/tsc/tsc.impl';
import { copyAssets } from '@nx/js';
import { ExecutorOptions as TscExecutorOptions } from '@nx/js/src/utils/schema';
import { existsSync, unlink, readFileSync, writeFileSync } from 'fs';
import { z } from 'zod';
import { promisify } from 'util';
import path from 'path';

const asyncUnlink = promisify(unlink);

const BuilderExecutorSchema = z.object({
  esmTsConfig: z.string().optional(),
  cjsTsConfig: z.string(),
  outputPath: z.string(),
});

export type BuilderExecutorSchemaType = Omit<TscExecutorOptions, 'tsConfig'> & z.infer<typeof BuilderExecutorSchema>;

async function removeEsmPackageJson(esmOutputPath: string) {
  const esmPackageJsonPath = `${esmOutputPath}/package.json`;
  if (existsSync(esmPackageJsonPath)) {
    return asyncUnlink(esmPackageJsonPath);
  }
}

/**
 * Transform workspace package.json for npm publishing
 *
 * Changes workspace paths (dist/index.js) to published paths (./index.js)
 * and removes workspace-only fields (exports) that conflict with nested package.json files
 */
export function transformPackageJsonForPublishing(packageJson: any): any {

  const transformed = { ...packageJson };

  const distPrefixRegex = /^.?\/?dist/;
  const distReplacementRegex = /.?\/?dist\//;
  const replacementString = './';

  // main field
  if (transformed.main && distPrefixRegex.test(transformed.main)) {
    transformed.main = transformed.main.replace( distReplacementRegex, replacementString );
  }

  // browser field
  if (transformed.browser && distPrefixRegex.test(transformed.browser)) {
    transformed.browser = transformed.browser.replace( distReplacementRegex, replacementString );
  }

  // bin field (can be string or object)
  if (transformed.bin) {
    if (typeof transformed.bin === 'string' && distPrefixRegex.test(transformed.bin)) {
      transformed.bin = transformed.bin.replace( distReplacementRegex, replacementString );
    } else if (typeof transformed.bin === 'object') {
      // Handle object bin field (e.g., { "fec": "./dist/bin/fec.js" })
      for (const [key, value] of Object.entries(transformed.bin)) {
        if (typeof value === 'string' && distPrefixRegex.test(value)) {
          transformed.bin[key] = value.replace( distReplacementRegex, replacementString );
        }
      }
    }
  }

  // module field
  if (transformed.module && distPrefixRegex.test(transformed.module)) {
    transformed.module = transformed.module.replace( distReplacementRegex, replacementString );
  }

  // types field
  if (transformed.types && distPrefixRegex.test(transformed.types)) {
    transformed.types = transformed.types.replace( distReplacementRegex, replacementString );
  }

  // typings field
  if (transformed.typings && distPrefixRegex.test(transformed.typings)) {
    transformed.typings = transformed.typings.replace( distReplacementRegex, replacementString);
  }

  // Remove exports field from published package.json
  // Granular imports are handled by nested package.json files generated by build-packages executor
  if (transformed.exports) {
    delete transformed.exports;
  }

  return transformed;
}

/**
 * Validate package.json configuration for frontend-components build process
 *
 * This validates SOURCE package.json files that serve as build inputs.
 * The build system automatically handles modern standards:
 * - build-packages executor generates exports field from component structure
 * - builder executor transforms dist/ paths to relative paths
 * - Final published package.json meets all ecosystem requirements
 *
 * @param packageJson Source package.json content
 * @param hasEsmBuild Whether package uses dual CJS/ESM build
 */
export function validatePackageJsonConfiguration(packageJson: any, hasEsmBuild: boolean) {
  // Require explicit type field (ecosystem consensus: Node.js, webpack, rspack)
  if (!packageJson.type) {
    throw new Error(
      'Missing required "type" field. All ecosystems (Node.js, webpack, rspack) ' +
      'recommend explicit declaration. Use "type": "commonjs" for dual CJS/ESM builds.'
    );
  }

  // Validate type field values
  if (!['module', 'commonjs'].includes(packageJson.type)) {
    throw new Error('"type" field must be "module" or "commonjs"');
  }

  // Browser field validation - require main field
  if (packageJson.browser && !packageJson.main) {
    throw new Error(
      'Found "browser" field without "main" field. Options:\n' +
      '1. Add "main" field as fallback\n' +
      '2. Migrate to exports field with browser condition:\n' +
      '   { "exports": { "browser": "./browser.js", "node": "./main.js" } }'
    );
  }

  // Dual build validation (CJS + ESM)
  if (hasEsmBuild) {
    if (!packageJson.main) {
      throw new Error(
        `No "main" field found in package.json. ` +
        `Add a "main" field pointing to your CJS entry point (e.g., "./dist/index.js").`
      );
    }
    if (!packageJson.module) {
      throw new Error(
        `ESM build requested but no "module" field found in package.json. ` +
        `Add a "module" field pointing to your ESM entry point (e.g., "./dist/esm/index.js") ` +
        `or remove esmTsConfig to skip ESM build.`
      );
    }
    if (packageJson.type === 'module') {
      throw new Error(
        `Dual packages should not use "type": "module". ` +
        `Remove the "type" field or set it to "commonjs" for maximum compatibility.`
      );
    }
  }
  // CJS-only build validation
  else {
    if (!packageJson.main) {
      throw new Error(
        `No "main" field found in package.json. ` +
        `Add a "main" field pointing to your entry point (e.g., "./dist/index.js").`
      );
    }
    if (packageJson.module) {
      throw new Error(
        `"module" field found in CJS-only package. ` +
        `Remove the "module" field or add esmTsConfig to enable dual builds.`
      );
    }
  }

  // CLI packages should use commonjs for compatibility
  if (packageJson.bin && packageJson.type === 'module') {
    throw new Error(
      `CLI packages should use "type": "commonjs" for maximum Node.js compatibility. ` +
      `Change "type" to "commonjs" or remove it.`
    );
  }
}

/**
 * Copy and transform package.json from workspace to dist directory
 *
 * Validates workspace config, transforms paths for publishing, and writes to dist/package.json
 */
async function copyPackageJsonWithTransform(sourcePath: string, outputPath: string, validateEsm: boolean = false) {
  try {
    const sourcePackageJson = JSON.parse(readFileSync(sourcePath, 'utf-8'));

    // Validate package.json configuration
    validatePackageJsonConfiguration(sourcePackageJson, validateEsm);

    const transformedPackageJson = transformPackageJsonForPublishing(sourcePackageJson);
    const destinationPath = path.join(outputPath, 'package.json');
    writeFileSync(destinationPath, JSON.stringify(transformedPackageJson, null, 2));
  } catch (error) {
    throw new Error(`Failed to copy and transform package.json: ${error}`);
  }
}

/**
 * Main executor: Builds TypeScript packages with dual CJS/ESM output
 *
 * 1. Compiles TypeScript to CommonJS (dist/) and ES modules (dist/esm/)
 * 2. Transforms package.json for publishing (strips dist/ paths, removes workspace fields)
 * 3. Copies assets and cleans up temporary files
 */
export default async function runExecutor(options: BuilderExecutorSchemaType, context: ExecutorContext) {
  try {
    BuilderExecutorSchema.parse(options);
  } catch (error) {
    throw new Error(`Invalid options passed to builder executor: ${error}`);
  }

  const projectName = context.projectName;
  if (!projectName) {
    throw new Error('Project name is required');
  }

  const currentProjectRoot = context.projectsConfigurations?.projects[projectName]?.root;
  if (!currentProjectRoot) {
    throw new Error('Project root is required');
  }

  async function resolveExecutors(...executorResults: ReturnType<typeof tscExecutor>[]) {
    for await (const executor of executorResults) {
      for await (const result of executor) {
        if (!result.success) {
          return { success: false };
        }
      }
    }
    return { success: true };
  }

  const { cjsTsConfig, esmTsConfig, ...tscOptions } = options;
  const esmOutputDir = options.outputPath + '/esm';
  const cjsTscOptions: TscExecutorOptions = { clean: false, ...tscOptions, tsConfig: cjsTsConfig };

  const tscExecutors = [tscExecutor(cjsTscOptions, context as any)];

  if (esmTsConfig) {
    const esmTscOptions: TscExecutorOptions = { clean: false, ...tscOptions, outputPath: esmOutputDir, tsConfig: esmTsConfig };
    tscExecutors.push(tscExecutor(esmTscOptions, context as any));
  }

  let executionResult = { success: false };
  const results = await Promise.all(tscExecutors);
  executionResult = await resolveExecutors(...results);
  if (!executionResult.success) {
    return executionResult;
  }

  if (esmTsConfig) {
    await removeEsmPackageJson(esmOutputDir);
  }

  // Copy and transform main package.json with stripped dist/ prefixes for publishing
  // Note: This only affects the main package.json - nested package.json files for granular imports
  // are handled separately by build-packages executor and already have correct entry points
  await copyPackageJsonWithTransform(`${currentProjectRoot}/package.json`, options.outputPath, !!esmTsConfig);

  // Copy other assets normally (excluding package.json since we handled it above)
  if (options.assets && options.assets.length > 0) {
    await copyAssets({ outputPath: options.outputPath, assets: options.assets }, context as any);
  }

  return executionResult;
}
